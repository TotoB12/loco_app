I am developing a simple mobile application that allows people to share their live location with others. I am currently trying to develop the part of it that will send regular location updates to the Firestone Database, and have it be fully functional on Android and iOS. I have it coded it in Native Expo React.
I want to have my app work as efficiently as possible, with great accuracy and low battery usage. Ideally, I want my app to have a background task that runs whenever the app is closed, sending the user's current location to their user item in the database. I am currently using Radar Labs' package to configure and setup location updates. I want to replicate the services of other apps like Google Maps sharing or WhatsApp sharing, but better. The best would be to have my app send a location update every minute. The database should hold the latest position as part of the user item, along with the timestamp.

Here is the current setup.

App.js
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { onAuthStateChanged } from 'firebase/auth';
import { auth, db } from './firebaseConfig';
import { doc, setDoc, serverTimestamp } from 'firebase/firestore';
import Radar from 'react-native-radar';

import * as Location from 'expo-location';
import * as IntentLauncher from 'expo-intent-launcher';
import { Linking, Platform } from 'react-native';

// Screens
import PermissionScreen from './screens/PermissionScreen'; // We'll define a new one below
import LoadingScreen from './screens/LoadingScreen';
import LoginScreen from './screens/LoginScreen';
import SignupScreen from './screens/SignupScreen';
import HomeScreen from './screens/HomeScreen';

const Stack = createStackNavigator();

export default function App() {
  // ----------------------------
  // 1) State for Location Perms
  // ----------------------------
  const [isCheckingPermissions, setIsCheckingPermissions] = useState(true);
  const [hasLocationPermissions, setHasLocationPermissions] = useState(false);
  const [permissionErrorMessage, setPermissionErrorMessage] = useState('');

  // ----------------------------
  // 2) State for Auth
  // ----------------------------
  const [user, setUser] = useState(null);
  const [initializing, setInitializing] = useState(true);

  // ----------------------------
  // 3) Check Location Perms
  //    On First Mount
  // ----------------------------
  useEffect(() => {
    (async () => {
      try {
        // 1) Request Foreground
        let fg = await Location.getForegroundPermissionsAsync();
        if (fg.status !== 'granted') {
          fg = await Location.requestForegroundPermissionsAsync();
          if (fg.status !== 'granted') {
            setPermissionErrorMessage(
              'App needs "While Using" location to function.'
            );
            setHasLocationPermissions(false);
            setIsCheckingPermissions(false);
            return;
          }
        }

        // 2) Request Background
        let bg = await Location.getBackgroundPermissionsAsync();
        if (bg.status !== 'granted') {
          bg = await Location.requestBackgroundPermissionsAsync();
        }

        if (bg.status !== 'granted') {
          // iOS may not grant 'Always' automatically. The user may have to manually enable it in Settings.
          setPermissionErrorMessage(
            'Please grant "Allow All the Time" location in Settings.'
          );
          setHasLocationPermissions(false);
        } else {
          setPermissionErrorMessage('');
          setHasLocationPermissions(true);
        }
      } catch (err) {
        console.log('Error checking permissions =>', err);
        setPermissionErrorMessage(
          'Error checking permissions. Please enable them in Settings.'
        );
        setHasLocationPermissions(false);
      } finally {
        setIsCheckingPermissions(false);
      }
    })();
  }, []);

  // ----------------------------
  // 4) Radar Setup
  //    But Only If We Have Perms
  // ----------------------------
  useEffect(() => {
    if (!hasLocationPermissions) return;

    // Initialize Radar
    Radar.initialize('prj_live_pk_2bb1459eda8faeaf64aa70990ca689ee231f5b42');
    Radar.setLogLevel('debug'); // Remove or set to 'none' in production

    // Listen for location updates
    Radar.on('location', async (result) => {
      console.log('Radar location event =>', result);

      // If user is logged in, push location to Firestore
      const currentUser = auth.currentUser;
      if (currentUser && result.location) {
        await setDoc(
          doc(db, 'users', currentUser.uid),
          {
            location: {
              latitude: result.location.latitude,
              longitude: result.location.longitude,
            },
            locationTimestamp: serverTimestamp(),
          },
          { merge: true }
        );
      }
    });

    Radar.on('error', (err) => {
      console.error('Radar error =>', err);
    });

    // Cleanup
    return () => {
      Radar.off('location');
      Radar.off('error');
    };
  }, [hasLocationPermissions]);

  // ----------------------------
  // 5) Auth Listener
  // ----------------------------
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (currentUser) => {
      setUser(currentUser);
      setInitializing(false);

      if (currentUser) {
        Radar.setUserId(currentUser.uid);
        Radar.setDescription(currentUser.email || 'Radar User');
        Radar.setMetadata({ role: 'tester' });

        // Request location permissions in two stages (foreground, then background)
        try {
          const fgStatus = await Radar.requestPermissions(false);
          console.log('Foreground perms =>', fgStatus);

          if (fgStatus === 'GRANTED_FOREGROUND') {
            const bgStatus = await Radar.requestPermissions(true);
            console.log('Background perms =>', bgStatus);
          }
        } catch (err) {
          console.error('Error requesting Radar permissions =>', err);
        }

        // Start custom tracking (only if we have perms)
        if (hasLocationPermissions) {
          // Configure the foreground notification on Android
          Radar.setForegroundServiceOptions({
            text: 'Location tracking is active',
            title: 'Tracking in background',
            updatesOnly: false,
            importance: 2,
          });

          Radar.startTrackingCustom({
            desiredStoppedUpdateInterval: 60, // every 60s when "stopped"
            fastestStoppedUpdateInterval: 60,
            desiredMovingUpdateInterval: 60,  // every 60s when "moving"
            fastestMovingUpdateInterval: 30,  // won't go faster than 30s
            desiredSyncInterval: 20,          // sync to Radar server every 20s
            desiredAccuracy: 'high',
            stopDuration: 140,                // how long before considered "stopped"
            stopDistance: 70,                 // how far to move before "moving"
            replay: 'none',                   // do not replay offline updates
            sync: 'all',                      // sync all location updates
            useStoppedGeofence: false,
            showBlueBar: false,               // iOS: if true, user sees blue bar
            foregroundServiceEnabled: true,   // Android: show a persistent notif
          });
        }
      } else {
        Radar.stopTracking();
      }
    });

    return () => unsubscribe();
  }, [hasLocationPermissions]);

  // ----------------------------
  // 6) Conditional Rendering
  // ----------------------------

  // 6a) If still checking perms, show spinner
  if (isCheckingPermissions) {
    return <LoadingScreen />;
  }

  // 6b) If we do NOT have location perms, block with a custom screen
  if (!hasLocationPermissions) {
    return (
      <PermissionBlockedScreen
        errorMessage={permissionErrorMessage}
        onOpenSettings={openAppSettings}
      />
    );
  }

  // 6c) If still initializing auth, show spinner
  if (initializing) {
    return <LoadingScreen />;
  }

  // 6d) If we have perms and have done auth check, show normal navigation
  return (
    <NavigationContainer>
      <Stack.Navigator>
        {user ? (
          <Stack.Screen
            name="Home"
            component={HomeScreen}
            options={{ headerShown: false }}
          />
        ) : (
          <>
            <Stack.Screen
              name="Login"
              component={LoginScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="Signup"
              component={SignupScreen}
              options={{ headerShown: false }}
            />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// Helper function to open App Settings:
function openAppSettings() {
  if (Platform.OS === 'ios') {
    Linking.openURL('app-settings:');
  } else {
    // Replace "com.yourcompany.yourapp" with your actual Android package name
    IntentLauncher.startActivityAsync(
      IntentLauncher.ActivityAction.APPLICATION_DETAILS_SETTINGS,
      { data: 'package:com.antoninbeliard.loco' }
    );
  }
}

// Minimal “blocked permissions” screen:
function PermissionBlockedScreen({ errorMessage, onOpenSettings }) {
  return (
    <PermissionScreen
      title="Location Needed"
      message={errorMessage}
      buttonText="Open Settings"
      onPressButton={onOpenSettings}
    />
  );
}
```

screens/HomeScreen.js
```javascript
// screens/HomeScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Button,
  TextInput,
  SafeAreaView,
  ScrollView,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { signOut } from 'firebase/auth';
import { auth, db } from '../firebaseConfig';
import { get, ref, update, onValue, off } from 'firebase/database';
import Radar from 'react-native-radar';
import Mapbox, { MapView, LocationPuck } from '@rnmapbox/maps';
import { MaterialIcons } from '@expo/vector-icons';
import { FontAwesome5 } from '@expo/vector-icons';
import { SearchBar, ListItem, Divider, Avatar } from '@rneui/themed';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';

import {
  getSharingStatus,
  shareLocation,
  stopSharingLocation,
  stopReceivingLocation,
} from '../sharingUtils';

export default function HomeScreen() {
  // ------------------------------
  // State variables
  // ------------------------------
  const [currentLocation, setCurrentLocation] = useState(null);

  // Settings modal state
  const [showSettings, setShowSettings] = useState(false);
  const [settingsFirstName, setSettingsFirstName] = useState('');
  const [settingsLastName, setSettingsLastName] = useState('');
  const [firstNameError, setFirstNameError] = useState(false);
  const [lastNameError, setLastNameError] = useState(false);
  const [avatarUri, setAvatarUri] = useState(null);
  const [avatarData, setAvatarData] = useState(null); // full avatar object from the DB
  const [uploading, setUploading] = useState(false);

  // Social (People) modal state
  const [showSocial, setShowSocial] = useState(false);
  const [expanded1, setExpanded1] = useState(false);
  const [expanded2, setExpanded2] = useState(true);
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  // New: States for accordions lists (real-time sharing lists)
  const [sharingWithList, setSharingWithList] = useState([]);
  const [receivingFromList, setReceivingFromList] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [showSharingDialog, setShowSharingDialog] = useState(false);
  const [sharingStatus, setSharingStatus] = useState({ amSharing: false, amReceiving: false });

  const IMGUR_CLIENT_ID = '4916641447bc9f6';

  // ------------------------------
  // Mapbox Token & Telemetry
  // ------------------------------
  useEffect(() => {
    Mapbox.setAccessToken(
      'pk.eyJ1IjoidG90b2IxMjE3IiwiYSI6ImNsbXo4NHdocjA4dnEya215cjY0aWJ1cGkifQ.OMzA6Q8VnHLHZP-P8ACBRw'
    );
    Mapbox.setTelemetryEnabled(false);
  }, []);

  // ------------------------------
  // Radar foreground tracking
  // ------------------------------
  useEffect(() => {
    // Track location once every 10 seconds when in foreground
    const intervalId = setInterval(() => {
      Radar.trackOnce({ desiredAccuracy: 'high' })
        .then((result) => {
          if (result.location) {
            setCurrentLocation(result.location);
          }
        })
        .catch((err) => {
          console.log('Radar trackOnce error =>', err);
        });
    }, 10000);

    return () => clearInterval(intervalId);
  }, []);

  // ------------------------------
  // When Settings modal opens:
  //   - Reset error states
  //   - Fetch current profile data from the DB
  // ------------------------------
  useEffect(() => {
    if (showSettings) {
      setFirstNameError(false);
      setLastNameError(false);
      const user = auth.currentUser;
      if (user) {
        get(ref(db, 'users/' + user.uid))
          .then((snapshot) => {
            if (snapshot.exists()) {
              const data = snapshot.val();
              setSettingsFirstName(data.firstName || '');
              setSettingsLastName(data.lastName || '');
              if (data.avatar) {
                setAvatarData(data.avatar);
                setAvatarUri(data.avatar.link || null);
              } else {
                setAvatarData(null);
                setAvatarUri(null);
              }
            }
          })
          .catch((err) => {
            console.log('Error fetching settings data:', err);
          });
      }
    }
  }, [showSettings]);

  // ------------------------------
  // Search Users from Realtime Database (excluding self)
  // ------------------------------
  useEffect(() => {
    if (search.trim().length > 0) {
      const currentUser = auth.currentUser;
      const usersRef = ref(db, 'users');
      get(usersRef)
        .then((snapshot) => {
          if (snapshot.exists()) {
            const usersData = snapshot.val();
            const searchLower = search.toLowerCase();
            let results = [];
            for (const uid in usersData) {
              // Exclude the currently signed-in user
              if (currentUser && uid === currentUser.uid) {
                continue;
              }
              const user = usersData[uid];
              const firstName = user.firstName || '';
              const lastName = user.lastName || '';
              const email = user.email || '';
              // Combine first and last name (trim extra spaces)
              const fullName = (firstName + ' ' + lastName).trim().toLowerCase();
              // Check if the search term is part of the full name or the email
              if (
                fullName.includes(searchLower) ||
                email.toLowerCase().includes(searchLower)
              ) {
                results.push({ uid, ...user });
              }
            }
            setSearchResults(results);
          } else {
            setSearchResults([]);
          }
        })
        .catch((err) => {
          console.error('Error fetching users:', err);
          setSearchResults([]);
        });
    } else {
      setSearchResults([]);
    }
  }, [search]);

  // ------------------------------
  // Real-time Listeners for Sharing Lists
  // ------------------------------
  useEffect(() => {
    const currentUser = auth.currentUser;
    if (!currentUser) return;

    const sharingWithRef = ref(db, `users/${currentUser.uid}/sharingWith`);
    const receivingFromRef = ref(db, `users/${currentUser.uid}/receivingFrom`);

    // Listener for "Sharing With" list:
    const sharingWithListener = onValue(sharingWithRef, async (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const uids = Object.keys(data);
        const userPromises = uids.map(async (uid) => {
          const userSnap = await get(ref(db, `users/${uid}`));
          return userSnap.exists() ? { uid, ...userSnap.val() } : null;
        });
        const users = await Promise.all(userPromises);
        setSharingWithList(users.filter((u) => u !== null));
      } else {
        setSharingWithList([]);
      }
    });

    // Listener for "Receiving From" list:
    const receivingFromListener = onValue(receivingFromRef, async (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const uids = Object.keys(data);
        const userPromises = uids.map(async (uid) => {
          const userSnap = await get(ref(db, `users/${uid}`));
          return userSnap.exists() ? { uid, ...userSnap.val() } : null;
        });
        const users = await Promise.all(userPromises);
        setReceivingFromList(users.filter((u) => u !== null));
      } else {
        setReceivingFromList([]);
      }
    });

    // Cleanup the listeners when unmounting:
    return () => {
      off(sharingWithRef, 'value', sharingWithListener);
      off(receivingFromRef, 'value', receivingFromListener);
    };
  }, []);

  // ------------------------------
  // Validation for Name Fields
  // ------------------------------
  const validateName = (name) => {
    const regex = /^[A-Za-z]+$/;
    return name.trim().length > 0 && name.length <= 20 && regex.test(name);
  };

  const handleFirstNameChange = (text) => {
    setSettingsFirstName(text);
    if (validateName(text)) {
      setFirstNameError(false);
      const user = auth.currentUser;
      if (user) {
        update(ref(db, 'users/' + user.uid), { firstName: text }).catch((err) =>
          console.log('Error updating first name:', err)
        );
      }
    } else {
      setFirstNameError(true);
    }
  };

  const handleLastNameChange = (text) => {
    setSettingsLastName(text);
    if (validateName(text)) {
      setLastNameError(false);
      const user = auth.currentUser;
      if (user) {
        update(ref(db, 'users/' + user.uid), { lastName: text }).catch((err) =>
          console.log('Error updating last name:', err)
        );
      }
    } else {
      setLastNameError(true);
    }
  };

  // ------------------------------
  // Sign Out Logic
  // ------------------------------
  const handleSignOut = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.log('Error signing out:', error);
    }
  };

  // ------------------------------
  // New: Delete an image from Imgur using its deletehash
  // ------------------------------
  const deleteImgurImage = async (deleteHash) => {
    try {
      const authHeader = 'Client-ID ' + IMGUR_CLIENT_ID;
      const response = await fetch(`https://api.imgur.com/3/image/${deleteHash}`, {
        method: 'DELETE',
        headers: {
          Authorization: authHeader,
          Accept: 'application/json',
        },
      });
      const result = await response.json();
      if (result.success) {
        console.log('Old avatar deleted successfully from Imgur');
      } else {
        console.error('Failed to delete old avatar from Imgur:', result);
      }
    } catch (error) {
      console.error('Error deleting old avatar:', error);
    }
  };

  const resizeImageIfNeeded = async (uri, width, height) => {
    if (width <= 500 && height <= 500) {
      return uri;
    }
    const maxDimension = 1000;
    const scaleFactor = Math.min(maxDimension / width, maxDimension / height);
    const newWidth = Math.round(width * scaleFactor);
    const newHeight = Math.round(height * scaleFactor);
    const manipResult = await ImageManipulator.manipulateAsync(
      uri,
      [{ resize: { width: newWidth, height: newHeight } }],
      { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
    );
    return manipResult.uri;
  };

  // ------------------------------
  // New: Upload image to Imgur and update the DB
  // ------------------------------
  const uploadImage = async (uri) => {
    try {
      setUploading(true);
      let formData = new FormData();
      const uriParts = uri.split('.');
      const fileType = uriParts[uriParts.length - 1];
      formData.append('image', {
        uri: uri,
        name: `avatar.${fileType}`,
        type: `image/${fileType}`,
      });

      const authHeader = 'Client-ID ' + IMGUR_CLIENT_ID;
      const response = await fetch('https://api.imgur.com/3/image', {
        method: 'POST',
        headers: {
          Authorization: authHeader,
          Accept: 'application/json',
        },
        body: formData,
      });

      const result = await response.json();

      if (result.success) {
        if (avatarData && avatarData.deletehash) {
          await deleteImgurImage(avatarData.deletehash);
        }
        const currentUser = auth.currentUser;
        if (currentUser) {
          await update(ref(db, 'users/' + currentUser.uid), { avatar: result.data });
          setAvatarData(result.data);
          setAvatarUri(result.data.link);
          Alert.alert('Success', 'Avatar updated successfully.');
        } else {
          Alert.alert('Error', 'User not logged in.');
        }
      } else {
        console.error('Imgur upload failed:', result);
        Alert.alert('Upload failed', 'Failed to upload image to Imgur.');
      }
    } catch (error) {
      console.error('Error uploading image:', error);
      Alert.alert('Error', 'An error occurred while uploading the image.');
    } finally {
      setUploading(false);
    }
  };

  // ------------------------------
  // New: Handle image selection using expo-image-picker
  // ------------------------------
  const handleSelectImage = async () => {
    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (!permissionResult.granted) {
      Alert.alert('Permission required', 'Permission to access the media library is required!');
      return;
    }

    let pickerResult = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });

    if (!pickerResult.canceled) {
      const asset = pickerResult.assets[0];
      const resizedUri = await resizeImageIfNeeded(asset.uri, asset.width, asset.height);
      await uploadImage(resizedUri);
    }
  };

  // ------------------------------
  // New: Handle removing the current profile picture
  // ------------------------------
  const handleRemovePicture = async () => {
    if (!avatarData || !avatarData.deletehash) {
      Alert.alert('No avatar', 'No avatar to remove.');
      return;
    }
    try {
      setUploading(true);
      await deleteImgurImage(avatarData.deletehash);
      const currentUser = auth.currentUser;
      if (currentUser) {
        await update(ref(db, 'users/' + currentUser.uid), { avatar: null });
        setAvatarData(null);
        setAvatarUri(null);
        Alert.alert('Success', 'Avatar removed successfully.');
      } else {
        Alert.alert('Error', 'User not logged in.');
      }
    } catch (error) {
      console.error('Error removing avatar:', error);
      Alert.alert('Error', 'An error occurred while removing the avatar.');
    } finally {
      setUploading(false);
    }
  };

  // ------------------------------
  // New: Reusable Component for Displaying a User with Sharing Status
  // ------------------------------
  const UserListItem = ({ user, onPress }) => {
    const [statusText, setStatusText] = useState('');

    useEffect(() => {
      const fetchStatus = async () => {
        const currentUser = auth.currentUser;
        if (!currentUser) return;
        try {
          const status = await getSharingStatus(currentUser.uid, user.uid);
          let text = '';
          if (status.amSharing && status.amReceiving) {
            text = 'Both of you are sharing';
          } else if (status.amSharing && !status.amReceiving) {
            text = 'Receiving your location';
          } else if (!status.amSharing && status.amReceiving) {
            text = 'Is sharing with you';
          } else {
            text = 'Neither of you are sharing';
          }
          setStatusText(text);
        } catch (err) {
          console.error(err);
        }
      };
      fetchStatus();
    }, [user]);

    return (
      <ListItem bottomDivider onPress={() => onPress(user)}>
        <Avatar
          rounded
          source={
            user.avatar && user.avatar.link
              ? { uri: user.avatar.link }
              : undefined
          }
          icon={
            !user.avatar || !user.avatar.link
              ? { name: 'person-outline', type: 'material', size: 26 }
              : undefined
          }
          containerStyle={
            !user.avatar || !user.avatar.link
              ? { backgroundColor: '#c2c2c2' }
              : {}
          }
        />
        <ListItem.Content>
          <ListItem.Title>
            {(`${user.firstName || ''} ${user.lastName || ''}`).trim()}
          </ListItem.Title>
          <ListItem.Subtitle>{statusText}</ListItem.Subtitle>
        </ListItem.Content>
      </ListItem>
    );
  };

  // ------------------------------
  // Sharing Dialog (same as before)
  // ------------------------------
  function SharingDialog({
    targetUser,
    sharingStatus,
    onShare,
    onStopSharing,
    onStopReceiving,
    onClose,
  }) {
    let message = '';
    let actions = [];

    if (sharingStatus.amSharing && !sharingStatus.amReceiving) {
      // Case 1: You are sharing, they are not.
      message = `You are sharing your location with ${targetUser.firstName}`;
      actions.push({ title: 'Stop Sharing My Location', onPress: onStopSharing });
    } else if (!sharingStatus.amSharing && sharingStatus.amReceiving) {
      // Case 2: They are sharing with you, but you’re not.
      message = `${targetUser.firstName} is sharing their location`;
      actions.push({ title: 'Share My Location', onPress: onShare });
      actions.push({ title: `Remove ${targetUser.firstName}`, onPress: onStopReceiving });
    } else if (sharingStatus.amSharing && sharingStatus.amReceiving) {
      // Case 3: Both are sharing.
      message = 'You are both sharing';
      actions.push({ title: 'Stop Sharing My Location', onPress: onStopSharing });
      actions.push({ title: `Remove ${targetUser.firstName}`, onPress: onStopReceiving });
    } else {
      // Case 4: Neither are sharing.
      message = 'Neither of you are sharing';
      actions.push({ title: 'Share My Location', onPress: onShare });
    }

    return (
      <View style={SharingStyles.dialogContainer}>
        <Text style={SharingStyles.dialogMessage}>{message}</Text>
        {actions.map((action, index) => (
          <View key={index} style={SharingStyles.buttonContainer}>
            <Button
              title={action.title}
              onPress={() => {
                action.onPress();
                onClose();
              }}
            />
          </View>
        ))}
        <View style={SharingStyles.buttonContainer}>
          <Button title="Cancel" onPress={onClose} />
        </View>
      </View>
    );
  }

  // Called when a search result or list item is tapped.
  const handleUserPress = async (user) => {
    const currentUser = auth.currentUser;
    if (!currentUser) return;

    // Check sharing status between the current user and the tapped user.
    const status = await getSharingStatus(currentUser.uid, user.uid);
    setSharingStatus(status);
    setSelectedUser(user);
    setShowSharingDialog(true);
  };

  // ------------------------------
  // Render
  // ------------------------------
  return (
    <View style={styles.container}>
      {/* Full-screen Map */}
      <MapView
        style={StyleSheet.absoluteFillObject}
        attributionEnabled={false}
        logoEnabled={false}
        scaleBarEnabled={false}
        compassEnabled={true}
        compassViewPosition={1}
        compassViewMargins={{ x: 15, y: 64 }}
        compassFadeWhenNorth={false}
      >
        {/* Shows a blue dot for user location */}
        <LocationPuck
          topImage="topImage"
          visible={true}
          scale={['interpolate', ['linear'], ['zoom'], 10, 1.0, 20, 4.0]}
          pulsing={{
            isEnabled: true,
            color: 'teal',
            radius: 50.0,
          }}
        />
      </MapView>

      {/* Top row with Settings (left) and Friends (right) buttons */}
      <View style={styles.topRow}>
        <TouchableOpacity style={styles.iconButton} onPress={() => setShowSettings(true)}>
          <MaterialIcons name="settings" size={24} color="black" />
        </TouchableOpacity>
        <TouchableOpacity style={styles.iconButton} onPress={() => setShowSocial(true)}>
          <FontAwesome5 name="user-friends" size={20} color="black" />
        </TouchableOpacity>
      </View>

      {/* Current location text overlaid at bottom-right */}
      <View style={styles.locationInfo}>
        {currentLocation ? (
          <Text style={styles.locationText}>
            Lat: {currentLocation.latitude.toFixed(6)}
            {'\n'}Lng: {currentLocation.longitude.toFixed(6)}
          </Text>
        ) : (
          <Text style={styles.locationText}>No location yet...</Text>
        )}
      </View>

      {/* Sign out button overlaid at bottom-left */}
      <TouchableOpacity style={styles.signOutButton} onPress={handleSignOut}>
        <Text style={styles.signOutText}>Log Out</Text>
      </TouchableOpacity>

      {/* ------------- Settings Modal ------------- */}
      <Modal
        animationType="slide"
        transparent={false}
        visible={showSettings}
        onRequestClose={() => setShowSettings(false)}
      >
        <SafeAreaView style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Settings</Text>
            <TouchableOpacity onPress={() => setShowSettings(false)}>
              <MaterialIcons name="close" size={28} color="#000" />
            </TouchableOpacity>
          </View>
          <ScrollView style={styles.modalContent} contentContainerStyle={styles.modalScroll}>
            <View style={styles.avatarContainer}>
              <Avatar
                size={100}
                rounded
                source={avatarUri ? { uri: avatarUri } : null}
                icon={!avatarUri ? { name: 'person', type: 'material' } : undefined}
                containerStyle={styles.avatar}
              />
              {uploading && (
                <ActivityIndicator
                  style={{ marginVertical: 10 }}
                  size="small"
                  color="#00ADB5"
                />
              )}
              <View style={styles.avatarButtonsContainer}>
                <TouchableOpacity
                  style={styles.avatarButton}
                  onPress={handleSelectImage}
                  disabled={uploading}
                >
                  <Text style={styles.avatarButtonText}>Select Image</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={styles.avatarButton}
                  onPress={handleRemovePicture}
                  disabled={uploading}
                >
                  <Text style={styles.avatarButtonText}>Remove Picture</Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* First Name Field */}
            <Text style={styles.label}>First Name</Text>
            <TextInput
              style={[styles.input, firstNameError && styles.errorInput]}
              placeholder="First Name"
              value={settingsFirstName}
              onChangeText={handleFirstNameChange}
            />

            {/* Last Name Field */}
            <Text style={styles.label}>Last Name</Text>
            <TextInput
              style={[styles.input, lastNameError && styles.errorInput]}
              placeholder="Last Name"
              value={settingsLastName}
              onChangeText={handleLastNameChange}
            />
          </ScrollView>
        </SafeAreaView>
      </Modal>

      {/* ------------- People (Social) Modal ------------- */}
      <Modal
        animationType="slide"
        transparent={false}
        visible={showSocial}
        onRequestClose={() => setShowSocial(false)}
      >
        <SafeAreaView style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>People</Text>
            <TouchableOpacity onPress={() => setShowSocial(false)}>
              <MaterialIcons name="close" size={28} color="#000" />
            </TouchableOpacity>
          </View>
          <ScrollView style={styles.modalContent} contentContainerStyle={styles.modalScroll}>
            <SearchBar
              placeholder="Search..."
              onChangeText={setSearch}
              value={search}
              platform="default"
              containerStyle={styles.searchContainer}
              inputContainerStyle={styles.searchInputContainer}
              inputStyle={styles.searchInput}
            />

            {/* If there is at least one character in the search field, show search results */}
            {search.trim().length > 0 ? (
              <>
                {searchResults.length > 0 ? (
                  searchResults.map((user) => (
                    <UserListItem key={user.uid} user={user} onPress={handleUserPress} />
                  ))
                ) : (
                  <Text style={{ textAlign: 'center', marginTop: 20 }}>
                    No users found.
                  </Text>
                )}
              </>
            ) : (
              <>
                <ListItem.Accordion
                  content={
                    <ListItem.Content>
                      <ListItem.Title>Sharing With</ListItem.Title>
                    </ListItem.Content>
                  }
                  isExpanded={expanded1}
                  onPress={() => setExpanded1(!expanded1)}
                >
                  {sharingWithList.length > 0 ? (
                    sharingWithList.map((user) => (
                      <UserListItem key={user.uid} user={user} onPress={handleUserPress} />
                    ))
                  ) : (
                    <Text style={{ margin: 10, textAlign: 'center' }}>
                      You are not sharing your location yet.
                    </Text>
                  )}
                </ListItem.Accordion>

                <Divider
                  style={{ width: '100%' }}
                  insetType="middle"
                  width={1}
                  orientation="horizontal"
                />

                <ListItem.Accordion
                  content={
                    <ListItem.Content>
                      <ListItem.Title>Receiving Locations</ListItem.Title>
                    </ListItem.Content>
                  }
                  isExpanded={expanded2}
                  onPress={() => setExpanded2(!expanded2)}
                >
                  {receivingFromList.length > 0 ? (
                    receivingFromList.map((user) => (
                      <UserListItem key={user.uid} user={user} onPress={handleUserPress} />
                    ))
                  ) : (
                    <Text style={{ margin: 10, textAlign: 'center' }}>
                      Nobody has shared with you yet.
                    </Text>
                  )}
                </ListItem.Accordion>
              </>
            )}
          </ScrollView>
        </SafeAreaView>
      </Modal>

      {showSharingDialog && selectedUser && (
        <Modal
          animationType="fade"
          transparent={true}
          visible={showSharingDialog}
          onBackdropPress={() => setShowSharingDialog(false)}
          onRequestClose={() => setShowSharingDialog(false)}
        >
          <View style={dialogStyles.overlay}>
            <View style={dialogStyles.dialogBox}>
              <SharingDialog
                targetUser={selectedUser}
                sharingStatus={sharingStatus}
                onShare={async () => {
                  await shareLocation(auth.currentUser.uid, selectedUser.uid);
                  // Optionally, update sharingStatus if needed.
                }}
                onStopSharing={async () => {
                  await stopSharingLocation(auth.currentUser.uid, selectedUser.uid);
                }}
                onStopReceiving={async () => {
                  await stopReceivingLocation(auth.currentUser.uid, selectedUser.uid);
                }}
                onClose={() => setShowSharingDialog(false)}
              />
            </View>
          </View>
        </Modal>
      )}
    </View>
  );
}

// ------------------------------
// Styles
// ------------------------------
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  topRow: {
    position: 'absolute',
    top: 10,
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 15,
    zIndex: 999,
  },
  iconButton: {
    width: 47,
    height: 47,
    borderRadius: 25,
    backgroundColor: '#fff',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
  },
  locationInfo: {
    position: 'absolute',
    bottom: 40,
    right: 15,
    backgroundColor: 'rgba(0,0,0,0.3)',
    padding: 8,
    borderRadius: 5,
  },
  locationText: {
    color: '#fff',
    textAlign: 'left',
  },
  signOutButton: {
    position: 'absolute',
    bottom: 40,
    left: 15,
    backgroundColor: '#f54242',
    borderRadius: 5,
    paddingHorizontal: 15,
    paddingVertical: 10,
  },
  signOutText: {
    color: '#fff',
    fontSize: 16,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  modalTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#000',
  },
  modalContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingVertical: 10,
  },
  modalScroll: {
    flexGrow: 1,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
    padding: 10,
    marginBottom: 15,
  },
  errorInput: {
    borderColor: 'red',
  },
  label: {
    fontSize: 16,
    color: '#000',
    marginBottom: 5,
    marginTop: 15,
  },
  searchContainer: {
    backgroundColor: 'transparent',
    borderTopWidth: 0,
    borderBottomWidth: 0,
    paddingHorizontal: 0,
    marginBottom: 20,
  },
  searchInputContainer: {
    backgroundColor: '#eee',
    borderRadius: 5,
  },
  searchInput: {
    color: '#000',
  },
  avatarContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  avatar: {
    backgroundColor: '#ccc',
  },
  avatarButtonsContainer: {
    flexDirection: 'row',
    marginTop: 10,
  },
  avatarButton: {
    backgroundColor: '#00ADB5',
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 5,
    marginHorizontal: 5,
  },
  avatarButtonText: {
    color: '#fff',
  },
});

const dialogStyles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  dialogBox: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 20,
    marginHorizontal: 20,
    width: '80%',
  },
});

const SharingStyles = StyleSheet.create({
  dialogContainer: {
    backgroundColor: '#fff',
    padding: 20,
    marginHorizontal: 20,
    borderRadius: 8,
    alignItems: 'center',
  },
  dialogMessage: {
    fontSize: 16,
    marginBottom: 15,
    textAlign: 'center',
  },
  buttonContainer: {
    marginVertical: 5,
    width: '100%',
  },
});
```

screens/LoginScreen.js
```javascript
// screens/LoginScreen.js
import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  Alert,
  StyleSheet,
  KeyboardAvoidingView,
  ScrollView,
  Platform,
} from 'react-native';
import { signInWithEmailAndPassword } from 'firebase/auth';
import { auth } from '../firebaseConfig';

export default function LoginScreen({ navigation }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = async () => {
    try {
      if (!email || !password) {
        Alert.alert('Error', 'Please fill in all fields');
        return;
      }

      await signInWithEmailAndPassword(auth, email.trim(), password);
      // On success, the user is automatically tracked by `onAuthStateChanged`
      // in App.js, which navigates them to Home screen
    } catch (error) {
      Alert.alert('Login Error', error.message);
    }
  };

  return (
    <KeyboardAvoidingView
      style={{ flex: 1 }}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        keyboardShouldPersistTaps="handled"
      >
        <View style={styles.inner}>
          <Text style={styles.title}>Login</Text>

          <TextInput
            style={styles.input}
            placeholder="Email"
            placeholderTextColor="#999"
            value={email}
            onChangeText={(text) => setEmail(text)}
            keyboardType="email-address"
            autoCapitalize="none"
          />

          <TextInput
            style={styles.input}
            placeholder="Password"
            placeholderTextColor="#999"
            secureTextEntry
            value={password}
            onChangeText={(text) => setPassword(text)}
          />

          <TouchableOpacity style={styles.button} onPress={handleLogin}>
            <Text style={styles.buttonText}>Log In</Text>
          </TouchableOpacity>

          <TouchableOpacity onPress={() => navigation.navigate('Signup')}>
            <Text style={{ marginTop: 20, color: '#0275d8' }}>
              Don’t have an account? Sign up
            </Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  scrollContainer: {
    flexGrow: 1,
  },
  inner: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
    backgroundColor: '#212832', // or your preferred background
  },
  title: {
    fontSize: 32,
    color: '#fff',
    marginBottom: 30,
    textAlign: 'center',
  },
  input: {
    width: '100%',
    height: 50,
    backgroundColor: '#333',
    borderRadius: 5,
    paddingHorizontal: 15,
    color: '#fff',
    marginBottom: 15,
  },
  button: {
    height: 50,
    backgroundColor: '#00ADB5',
    borderRadius: 5,
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: 15,
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
  },
});
```

screens/SignupScreen.js
```javascript
// screens/SignupScreen.js
import React, { useState } from 'react';
import {
    View,
    Text,
    TextInput,
    TouchableOpacity,
    Alert,
    StyleSheet,
    KeyboardAvoidingView,
    ScrollView,
    Platform,
} from 'react-native';
import { createUserWithEmailAndPassword } from 'firebase/auth';
import { ref, set } from 'firebase/database';

import { auth, db } from '../firebaseConfig';

export default function SignupScreen({ navigation }) {
    const [firstName, setFirstName] = useState('');
    const [lastName, setLastName] = useState('');
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSignup = async () => {
        try {
            if (!firstName || !lastName || !email || !password) {
                Alert.alert('Error', 'Please fill in all fields');
                return;
            }
            const userCredential = await createUserWithEmailAndPassword(
                auth,
                email.trim(),
                password
            );
            const user = userCredential.user;
            // Save user data to the Realtime Database
            await set(ref(db, 'users/' + user.uid), {
                createdAt: { ".sv": "timestamp" },
                firstName: firstName.trim(),
                lastName: lastName.trim(),
                email: email.trim(),
            });
            Alert.alert('Success', 'Account created successfully');
        } catch (error) {
            Alert.alert('Signup Error', error.message);
        }
    };

    return (
        <KeyboardAvoidingView
            style={{ flex: 1 }}
            behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        >
            <ScrollView
                contentContainerStyle={styles.scrollContainer}
                keyboardShouldPersistTaps="handled"
            >
                <View style={styles.inner}>
                    <Text style={styles.title}>Sign Up</Text>

                    <TextInput
                        style={styles.input}
                        placeholder="First Name"
                        placeholderTextColor="#999"
                        value={firstName}
                        onChangeText={setFirstName}
                    />
                    <TextInput
                        style={styles.input}
                        placeholder="Last Name"
                        placeholderTextColor="#999"
                        value={lastName}
                        onChangeText={setLastName}
                    />
                    <TextInput
                        style={styles.input}
                        placeholder="Email"
                        placeholderTextColor="#999"
                        value={email}
                        onChangeText={setEmail}
                        keyboardType="email-address"
                        autoCapitalize="none"
                    />
                    <TextInput
                        style={styles.input}
                        placeholder="Password"
                        placeholderTextColor="#999"
                        secureTextEntry
                        value={password}
                        onChangeText={setPassword}
                    />

                    <TouchableOpacity style={styles.button} onPress={handleSignup}>
                        <Text style={styles.buttonText}>Create Account</Text>
                    </TouchableOpacity>

                    <TouchableOpacity onPress={() => navigation.navigate('Login')}>
                        <Text style={{ marginTop: 20, color: '#0275d8' }}>
                            Already have an account? Log in
                        </Text>
                    </TouchableOpacity>
                </View>
            </ScrollView>
        </KeyboardAvoidingView>
    );
}

const styles = StyleSheet.create({
    scrollContainer: {
        flexGrow: 1,
    },
    inner: {
        flex: 1,
        padding: 20,
        justifyContent: 'center',
    },
    title: {
        fontSize: 32,
        color: '#fff',
        marginBottom: 30,
        textAlign: 'center',
    },
    input: {
        width: '100%',
        height: 50,
        backgroundColor: '#333',
        borderRadius: 5,
        paddingHorizontal: 15,
        color: '#fff',
        marginBottom: 15,
    },
    button: {
        height: 50,
        backgroundColor: '#00ADB5',
        borderRadius: 5,
        alignItems: 'center',
        justifyContent: 'center',
        marginTop: 15,
    },
    buttonText: {
        color: '#fff',
        fontSize: 18,
    },
});
```

screens/LoadingScreen.js
```javascript
// screens/LoadingScreen.js
import React from 'react';
import { View, ActivityIndicator, StyleSheet } from 'react-native';

export default function LoadingScreen() {
  return (
    <View style={styles.container}>
      {/* Simple spinner in the center */}
      <ActivityIndicator size="large" color="#00ADB5" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#212832',
    alignItems: 'center',
    justifyContent: 'center',
  },
});
```

screens/PermissionScreen.js
```javascript
// screens/PermissionScreen.js
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

export default function PermissionScreen({
  title = 'Permissions Required',
  message = 'We need location permissions.',
  buttonText = 'Open Settings',
  onPressButton,
}) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>{title}</Text>
      <Text style={styles.message}>{message}</Text>
      {onPressButton && (
        <Button title={buttonText} onPress={onPressButton} />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#212832',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  title: {
    color: '#fff',
    fontSize: 20,
    marginBottom: 16,
    textAlign: 'center',
  },
  message: {
    color: '#fff',
    fontSize: 16,
    marginBottom: 24,
    textAlign: 'center',
  },
});
```

sharingUtils.js
```javascript
// sharingUtils.js
import { ref, update, get } from 'firebase/database';
import { db } from './firebaseConfig';

/**
 * Returns the sharing status between the current user and a target user.
 * @param {string} currentUid – Your UID.
 * @param {string} targetUid – The target user's UID.
 * @returns {Promise<{amSharing: boolean, amReceiving: boolean}>}
 */
export const getSharingStatus = async (currentUid, targetUid) => {
  try {
    // Check whether targetUid is in your sharingWith and receivingFrom lists.
    const sharingWithSnap = await get(ref(db, `users/${currentUid}/sharingWith/${targetUid}`));
    const receivingFromSnap = await get(ref(db, `users/${currentUid}/receivingFrom/${targetUid}`));
    return {
      amSharing: sharingWithSnap.exists(),
      amReceiving: receivingFromSnap.exists(),
    };
  } catch (error) {
    console.error('Error fetching sharing status:', error);
    return { amSharing: false, amReceiving: false };
  }
};

/**
 * Begins sharing your location with the target user.
 */
export const shareLocation = async (currentUid, targetUid) => {
  try {
    const updates = {};
    // Add targetUid to your sharingWith list…
    updates[`users/${currentUid}/sharingWith/${targetUid}`] = true;
    // …and add your uid to the target's receivingFrom list.
    updates[`users/${targetUid}/receivingFrom/${currentUid}`] = true;
    await update(ref(db), updates);
  } catch (error) {
    console.error('Error sharing location:', error);
  }
};

/**
 * Stops sharing your location with the target user.
 */
export const stopSharingLocation = async (currentUid, targetUid) => {
  try {
    const updates = {};
    // Remove targetUid from your sharingWith list…
    updates[`users/${currentUid}/sharingWith/${targetUid}`] = null;
    // …and remove your uid from the target's receivingFrom list.
    updates[`users/${targetUid}/receivingFrom/${currentUid}`] = null;
    await update(ref(db), updates);
  } catch (error) {
    console.error('Error stopping sharing location:', error);
  }
};

/**
 * Stops receiving the target user's location.
 */
export const stopReceivingLocation = async (currentUid, targetUid) => {
  try {
    const updates = {};
    // Remove targetUid from your receivingFrom list…
    updates[`users/${currentUid}/receivingFrom/${targetUid}`] = null;
    // …and remove your uid from the target's sharingWith list.
    updates[`users/${targetUid}/sharingWith/${currentUid}`] = null;
    await update(ref(db), updates);
  } catch (error) {
    console.error('Error stopping receiving location:', error);
  }
};
```

firebaseConfig.js
```javascript
// firebaseConfig.js
import { initializeApp } from 'firebase/app';
import { getDatabase } from 'firebase/database';
import { initializeAuth, getReactNativePersistence } from 'firebase/auth';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Replace with your own Firebase config!
const firebaseConfig = {
    apiKey: "AIzaSyAR24CQPymO-X5-6L-JeKRGfyqXm3n8MOs",
    authDomain: "totob12-loco.firebaseapp.com",
    projectId: "totob12-loco",
    storageBucket: "totob12-loco.firebasestorage.app",
    messagingSenderId: "1079141322842",
    appId: "1:1079141322842:web:ea9606c2ad097ea3f30863"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Set up Auth with persistence:
export const auth = initializeAuth(app, {
    persistence: getReactNativePersistence(AsyncStorage),
});

// Initialize and export the Realtime Database instead of Firestore:
export const db = getDatabase(app);
```

package.json
```json
{
  "name": "loco",
  "license": "0BSD",
  "version": "0.1.3",
  "main": "index.js",
  "scripts": {
    "start": "expo start --dev-client",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/stack": "^7.1.1",
    "@rnmapbox/maps": "^10.1.33",
    "dotenv": "^16.4.7",
    "expo": "~52.0.24",
    "expo-background-fetch": "~13.0.4",
    "expo-dev-client": "~5.0.9",
    "expo-location": "~18.0.5",
    "expo-status-bar": "~2.0.0",
    "expo-task-manager": "~12.0.4",
    "firebase": "^11.1.0",
    "react": "18.3.1",
    "react-native": "0.76.5",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-keyboard-aware-scroll-view": "^0.9.5",
    "react-native-maps": "1.18.0",
    "react-native-radar": "^3.19.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0"
  },
  "private": true
}
```

app.json
```json
import 'dotenv/config';

export default ({ config }) => {
  return {
    ...config,
    "name": "loco",
    "slug": "loco",
    "version": "0.1.3",
    "orientation": "portrait",
    "icon": "./assets/icon.jpg",
    "userInterfaceStyle": "dark",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#212832"
    },
    "newArchEnabled": false,
    "experiments": {
      "turboModules": false,
      "coreModules": false,
      "unoptimizedReports": false,
      "enableAsyncDefaults": false,
      "concurrentRoot": false,
      "fabric": false
    },
    "plugins": [
      [
        "react-native-radar",
        {
          "iosFraud": false,
          "iosNSLocationWhenInUseUsageDescription": "We use your location to help share your position in real-time.",
          "iosNSLocationAlwaysAndWhenInUseUsageDescription": "Background location is used so your friends can see your location even if the app is closed.",
          "iosBackgroundMode": true,
          "androidFraud": true,
          "androidBackgroundPermission": true,
          "androidFineLocationPermission": true,
          "addRadarSDKMotion": false
        }
      ],
      [
        "@rnmapbox/maps",
        {
          "RNMapboxMapsDownloadToken": process.env.MAPBOX_DOWNLOADS_TOKEN,
          "RNMapboxMapsVersion": "11.0.0"
        }
      ],
      [
        "expo-location",
        {
          "locationWhenInUsePermission": "Show current location on map."
        }
      ]
    ],
    "ios": {
      "supportsTablet": true,
      "infoPlist": {
        "UIBackgroundModes": [
          "location",
          "fetch"
        ],
        "NSLocationWhenInUseUsageDescription": "Show current location on map",
        "NSLocationAlwaysAndWhenInUseUsageDescription": "Background location usage..."
      },
      "config": {
        "googleMapsApiKey": "AIzaSyCCkJk7m5UqYt9_dHHxjA0zzvWKadSn41U"
      },
    },
    "android": {
      "package": "com.antoninbeliard.loco",
      "icon": "./assets/icon.png",
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#212832"
      },
      "permissions": [
        "ACCESS_FINE_LOCATION",
        "ACCESS_COARSE_LOCATION",
        "ACCESS_BACKGROUND_LOCATION",
        "android.permission.ACCESS_COARSE_LOCATION",
        "android.permission.ACCESS_FINE_LOCATION",
        "android.permission.ACCESS_BACKGROUND_LOCATION",
        "android.permission.FOREGROUND_SERVICE"
      ],
      "config": {
        "googleMaps": {
          "apiKey": "AIzaSyAgtPIWpSfr1a2dxUdBxXVw7Xah1yqL9YQ"
        }
      }
    },
    "extra": {
      "eas": {
        "projectId": "eacea42d-f4e8-4a94-b43a-f19dc934865e"
      }
    }
  };
};
```

This all works well, but I want to keep implementing the location sharing features. On the Home screen, I now want the map to display the user's that are sharing their location with me. Each user should be shown with their avatar (the picture from the database, or the avatar using the icon, like in the People modal), along with their first name on the right side (in black). These pucks/markers should move in real time as the updates come in. I want you to fully develop and implement this. Here is some documentation to help:

```
Marker View
Shows marker view and poitn annotations

import React from 'react';
import { Button, StyleSheet, View, Text, TouchableOpacity } from 'react-native';
import Mapbox from '@rnmapbox/maps';

import Bubble from '../common/Bubble';

const styles = StyleSheet.create({
  touchableContainer: { borderColor: 'black', borderWidth: 1.0, width: 60 },
  touchable: {
    backgroundColor: 'blue',
    width: 40,
    height: 40,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  touchableText: {
    color: 'white',
    fontWeight: 'bold',
  },
  matchParent: { flex: 1 },
});

const AnnotationContent = ({ title }: { title: string }) => (
  <View style={styles.touchableContainer}>
    <Text>{title}</Text>
    <TouchableOpacity style={styles.touchable}>
      <Text style={styles.touchableText}>Btn</Text>
    </TouchableOpacity>
  </View>
);
const INITIAL_COORDINATES: [number, number][] = [
  [-73.99155, 40.73581],
  [-73.99155, 40.73681],
];

const ShowMarkerView = () => {
  const [pointList, setPointList] =
    React.useState<GeoJSON.Position[]>(INITIAL_COORDINATES);
  const [allowOverlapWithPuck, setAllowOverlapWithPuck] =
    React.useState<boolean>(false);

  const onPressMap = (e: GeoJSON.Feature) => {
    const geometry = e.geometry as GeoJSON.Point;
    setPointList((pl) => [...pl, geometry.coordinates]);
  };

  return (
    <>
      <Button
        title={
          allowOverlapWithPuck
            ? 'allowOverlapWithPuck true'
            : 'allowOverlapWithPuck false'
        }
        onPress={() => setAllowOverlapWithPuck((prev) => !prev)}
      />
      <Mapbox.MapView onPress={onPressMap} style={styles.matchParent}>
        <Mapbox.Camera
          defaultSettings={{
            zoomLevel: 16,
            centerCoordinate: pointList[0],
          }}
        />

        <Mapbox.PointAnnotation coordinate={pointList[1]} id="pt-ann">
          <AnnotationContent title={'this is a point annotation'} />
        </Mapbox.PointAnnotation>

        <Mapbox.MarkerView
          coordinate={pointList[0]}
          allowOverlapWithPuck={allowOverlapWithPuck}
        >
          <AnnotationContent title={'this is a marker view'} />
        </Mapbox.MarkerView>

        {pointList.slice(2).map((coordinate, index) => (
          <Mapbox.PointAnnotation
            coordinate={coordinate}
            id={`pt-ann-${index}`}
            key={`pt-ann-${index}`}
          >
            <AnnotationContent title={'this is a point annotation'} />
          </Mapbox.PointAnnotation>
        ))}

        <Mapbox.NativeUserLocation />
      </Mapbox.MapView>

      <Bubble>
        <Text>Tap on map to add a point annotation</Text>
      </Bubble>
    </>
  );
};

export default ShowMarkerView;
```

Here is also exactly what I want the markers to look like:

```javascript
const UserMarker = ({ user }) => {
  return (
    <View style={markerStyles.container}>
      {user.avatar && user.avatar.link ? (
        <Image source={{ uri: user.avatar.link }} style={markerStyles.avatar} />
      ) : (
        <View style={markerStyles.defaultAvatar}>
          <Text style={markerStyles.defaultAvatarText}>
            {user.firstName ? user.firstName.charAt(0) : "?"}
          </Text>
        </View>
      )}
      <Text style={markerStyles.nameText}>{user.firstName}</Text>
    </View>
  );
};

const markerStyles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    padding: 5,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'gray',
  },
  avatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
  },
  defaultAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#c2c2c2',
    alignItems: 'center',
    justifyContent: 'center',
  },
  defaultAvatarText: {
    color: 'white',
    fontWeight: 'bold',
  },
  nameText: {
    color: 'black',
    marginLeft: 5,
    fontSize: 16,
  },
});
```

Give me the full new `HomeScreen.js` script.