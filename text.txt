I am developing a simple mobile application that allows people to share their live location with others. I am currently trying to develop the part of it that will send regular location updates to the Firestone Database, and have it be fully functional on Android and iOS. I have it coded it in Native Expo React.
I want to have my app work as efficiently as possible, with great accuracy and low battery usage. Ideally, I want my app to have a background task that runs whenever the app is closed, sending the user's current location to their user item in the database. I am currently using Radar Labs' package to configure and setup location updates. I want to replicate the services of other apps like Google Maps sharing or WhatsApp sharing, but better. The best would be to have my app send a location update every minute. The database should hold the latest position as part of the user item, along with the timestamp.

Here is the current setup.

App.js
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { onAuthStateChanged } from 'firebase/auth';
import { auth, db } from './firebaseConfig';
import { doc, setDoc, serverTimestamp } from 'firebase/firestore';
import Radar from 'react-native-radar';

import * as Location from 'expo-location';
import * as IntentLauncher from 'expo-intent-launcher';
import { Linking, Platform } from 'react-native';

// Screens
import PermissionScreen from './screens/PermissionScreen'; // We'll define a new one below
import LoadingScreen from './screens/LoadingScreen';
import LoginScreen from './screens/LoginScreen';
import SignupScreen from './screens/SignupScreen';
import HomeScreen from './screens/HomeScreen';

const Stack = createStackNavigator();

export default function App() {
  // ----------------------------
  // 1) State for Location Perms
  // ----------------------------
  const [isCheckingPermissions, setIsCheckingPermissions] = useState(true);
  const [hasLocationPermissions, setHasLocationPermissions] = useState(false);
  const [permissionErrorMessage, setPermissionErrorMessage] = useState('');

  // ----------------------------
  // 2) State for Auth
  // ----------------------------
  const [user, setUser] = useState(null);
  const [initializing, setInitializing] = useState(true);

  // ----------------------------
  // 3) Check Location Perms
  //    On First Mount
  // ----------------------------
  useEffect(() => {
    (async () => {
      try {
        // 1) Request Foreground
        let fg = await Location.getForegroundPermissionsAsync();
        if (fg.status !== 'granted') {
          fg = await Location.requestForegroundPermissionsAsync();
          if (fg.status !== 'granted') {
            setPermissionErrorMessage(
              'App needs "While Using" location to function.'
            );
            setHasLocationPermissions(false);
            setIsCheckingPermissions(false);
            return;
          }
        }

        // 2) Request Background
        let bg = await Location.getBackgroundPermissionsAsync();
        if (bg.status !== 'granted') {
          bg = await Location.requestBackgroundPermissionsAsync();
        }

        if (bg.status !== 'granted') {
          // iOS may not grant 'Always' automatically. The user may have to manually enable it in Settings.
          setPermissionErrorMessage(
            'Please grant "Allow All the Time" location in Settings.'
          );
          setHasLocationPermissions(false);
        } else {
          setPermissionErrorMessage('');
          setHasLocationPermissions(true);
        }
      } catch (err) {
        console.log('Error checking permissions =>', err);
        setPermissionErrorMessage(
          'Error checking permissions. Please enable them in Settings.'
        );
        setHasLocationPermissions(false);
      } finally {
        setIsCheckingPermissions(false);
      }
    })();
  }, []);

  // ----------------------------
  // 4) Radar Setup
  //    But Only If We Have Perms
  // ----------------------------
  useEffect(() => {
    if (!hasLocationPermissions) return;

    // Initialize Radar
    Radar.initialize('prj_live_pk_2bb1459eda8faeaf64aa70990ca689ee231f5b42');
    Radar.setLogLevel('debug'); // Remove or set to 'none' in production

    // Listen for location updates
    Radar.on('location', async (result) => {
      console.log('Radar location event =>', result);

      // If user is logged in, push location to Firestore
      const currentUser = auth.currentUser;
      if (currentUser && result.location) {
        await setDoc(
          doc(db, 'users', currentUser.uid),
          {
            location: {
              latitude: result.location.latitude,
              longitude: result.location.longitude,
            },
            locationTimestamp: serverTimestamp(),
          },
          { merge: true }
        );
      }
    });

    Radar.on('error', (err) => {
      console.error('Radar error =>', err);
    });

    // Cleanup
    return () => {
      Radar.off('location');
      Radar.off('error');
    };
  }, [hasLocationPermissions]);

  // ----------------------------
  // 5) Auth Listener
  // ----------------------------
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (currentUser) => {
      setUser(currentUser);
      setInitializing(false);

      if (currentUser) {
        Radar.setUserId(currentUser.uid);
        Radar.setDescription(currentUser.email || 'Radar User');
        Radar.setMetadata({ role: 'tester' });

        // Request location permissions in two stages (foreground, then background)
        try {
          const fgStatus = await Radar.requestPermissions(false);
          console.log('Foreground perms =>', fgStatus);

          if (fgStatus === 'GRANTED_FOREGROUND') {
            const bgStatus = await Radar.requestPermissions(true);
            console.log('Background perms =>', bgStatus);
          }
        } catch (err) {
          console.error('Error requesting Radar permissions =>', err);
        }

        // Start custom tracking (only if we have perms)
        if (hasLocationPermissions) {
          // Configure the foreground notification on Android
          Radar.setForegroundServiceOptions({
            text: 'Location tracking is active',
            title: 'Tracking in background',
            updatesOnly: false,
            importance: 2,
          });

          Radar.startTrackingCustom({
            desiredStoppedUpdateInterval: 60, // every 60s when "stopped"
            fastestStoppedUpdateInterval: 60,
            desiredMovingUpdateInterval: 60,  // every 60s when "moving"
            fastestMovingUpdateInterval: 30,  // won't go faster than 30s
            desiredSyncInterval: 20,          // sync to Radar server every 20s
            desiredAccuracy: 'high',
            stopDuration: 140,                // how long before considered "stopped"
            stopDistance: 70,                 // how far to move before "moving"
            replay: 'none',                   // do not replay offline updates
            sync: 'all',                      // sync all location updates
            useStoppedGeofence: false,
            showBlueBar: false,               // iOS: if true, user sees blue bar
            foregroundServiceEnabled: true,   // Android: show a persistent notif
          });
        }
      } else {
        Radar.stopTracking();
      }
    });

    return () => unsubscribe();
  }, [hasLocationPermissions]);

  // ----------------------------
  // 6) Conditional Rendering
  // ----------------------------

  // 6a) If still checking perms, show spinner
  if (isCheckingPermissions) {
    return <LoadingScreen />;
  }

  // 6b) If we do NOT have location perms, block with a custom screen
  if (!hasLocationPermissions) {
    return (
      <PermissionBlockedScreen
        errorMessage={permissionErrorMessage}
        onOpenSettings={openAppSettings}
      />
    );
  }

  // 6c) If still initializing auth, show spinner
  if (initializing) {
    return <LoadingScreen />;
  }

  // 6d) If we have perms and have done auth check, show normal navigation
  return (
    <NavigationContainer>
      <Stack.Navigator>
        {user ? (
          <Stack.Screen
            name="Home"
            component={HomeScreen}
            options={{ headerShown: false }}
          />
        ) : (
          <>
            <Stack.Screen
              name="Login"
              component={LoginScreen}
              options={{ headerShown: false }}
            />
            <Stack.Screen
              name="Signup"
              component={SignupScreen}
              options={{ headerShown: false }}
            />
          </>
        )}
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// Helper function to open App Settings:
function openAppSettings() {
  if (Platform.OS === 'ios') {
    Linking.openURL('app-settings:');
  } else {
    // Replace "com.yourcompany.yourapp" with your actual Android package name
    IntentLauncher.startActivityAsync(
      IntentLauncher.ActivityAction.APPLICATION_DETAILS_SETTINGS,
      { data: 'package:com.antoninbeliard.loco' }
    );
  }
}

// Minimal “blocked permissions” screen:
function PermissionBlockedScreen({ errorMessage, onOpenSettings }) {
  return (
    <PermissionScreen
      title="Location Needed"
      message={errorMessage}
      buttonText="Open Settings"
      onPressButton={onOpenSettings}
    />
  );
}
```

screens/HomeScreen.js
```javascript
// screens/HomeScreen.js
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  Button,
  TextInput,
  SafeAreaView,
  ScrollView,
  Alert,
  ActivityIndicator,
  Image,
} from 'react-native';
import { signOut } from 'firebase/auth';
import { auth, db } from '../firebaseConfig';
import { get, ref, update, onValue, off } from 'firebase/database';
import Radar from 'react-native-radar';
import Mapbox, { MapView, LocationPuck, MarkerView } from '@rnmapbox/maps';
import { MaterialIcons } from '@expo/vector-icons';
import { FontAwesome5 } from '@expo/vector-icons';
import { SearchBar, ListItem, Divider, Avatar } from '@rneui/themed';
import * as ImagePicker from 'expo-image-picker';
import * as ImageManipulator from 'expo-image-manipulator';

import {
  getSharingStatus,
  shareLocation,
  stopSharingLocation,
  stopReceivingLocation,
} from '../sharingUtils';

// ---------------------------------------------------------------------
// New: UserMarker component for displaying a sharing user’s marker
// ---------------------------------------------------------------------
const UserMarker = ({ user }) => {
  return (
    <View style={markerStyles.container}>
      <Avatar
        rounded
        source={
          user.avatar && user.avatar.link
            ? { uri: user.avatar.link }
            : undefined
        }
        icon={
          !user.avatar || !user.avatar.link
            ? { name: 'person-outline', type: 'material', size: 24 }
            : undefined
        }
        size={30}
        containerStyle={
          !user.avatar || !user.avatar.link
            ? { backgroundColor: '#c2c2c2' }
            : {}
        }
      />
      <Text style={markerStyles.nameText}>{user.firstName}</Text>
    </View>
  );
};

const markerStyles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'white',
    padding: 5,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: 'gray',
  },
  avatar: {
    width: 30,
    height: 30,
    borderRadius: 20,
  },
  defaultAvatar: {
    width: 20,
    height: 20,
    borderRadius: 20,
    backgroundColor: '#c2c2c2',
    alignItems: 'center',
    justifyContent: 'center',
  },
  defaultAvatarText: {
    color: 'white',
    fontWeight: 'bold',
  },
  nameText: {
    color: 'black',
    marginLeft: 5,
    fontSize: 16,
  },
});
// ---------------------------------------------------------------------

export default function HomeScreen() {
  // ------------------------------
  // State variables
  // ------------------------------
  const [currentLocation, setCurrentLocation] = useState(null);

  // Settings modal state
  const [showSettings, setShowSettings] = useState(false);
  const [settingsFirstName, setSettingsFirstName] = useState('');
  const [settingsLastName, setSettingsLastName] = useState('');
  const [firstNameError, setFirstNameError] = useState(false);
  const [lastNameError, setLastNameError] = useState(false);
  const [avatarUri, setAvatarUri] = useState(null);
  const [avatarData, setAvatarData] = useState(null); // full avatar object from the DB
  const [uploading, setUploading] = useState(false);

  // Social (People) modal state
  const [showSocial, setShowSocial] = useState(false);
  const [expanded1, setExpanded1] = useState(false);
  const [expanded2, setExpanded2] = useState(true);
  const [search, setSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  // Sharing lists from Realtime Database
  const [sharingWithList, setSharingWithList] = useState([]);
  const [receivingFromList, setReceivingFromList] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [showSharingDialog, setShowSharingDialog] = useState(false);
  const [sharingStatus, setSharingStatus] = useState({ amSharing: false, amReceiving: false });

  // NEW: Markers state – keyed by sharing user uid, with latest location & profile info
  const [markers, setMarkers] = useState({});

  const IMGUR_CLIENT_ID = '4916641447bc9f6';

  // ------------------------------
  // Mapbox Token & Telemetry
  // ------------------------------
  useEffect(() => {
    Mapbox.setAccessToken(
      'pk.eyJ1IjoidG90b2IxMjE3IiwiYSI6ImNsbXo4NHdocjA4dnEya215cjY0aWJ1cGkifQ.OMzA6Q8VnHLHZP-P8ACBRw'
    );
    Mapbox.setTelemetryEnabled(false);
  }, []);

  // ------------------------------
  // Radar foreground tracking
  // ------------------------------
  useEffect(() => {
    // Track location once every 10 seconds when in foreground
    const intervalId = setInterval(() => {
      Radar.trackOnce({ desiredAccuracy: 'high' })
        .then((result) => {
          if (result.location) {
            setCurrentLocation(result.location);
          }
        })
        .catch((err) => {
          console.log('Radar trackOnce error =>', err);
        });
    }, 10000);

    return () => clearInterval(intervalId);
  }, []);

  // ------------------------------
  // When Settings modal opens:
  //   - Reset error states
  //   - Fetch current profile data from the DB
  // ------------------------------
  useEffect(() => {
    if (showSettings) {
      setFirstNameError(false);
      setLastNameError(false);
      const user = auth.currentUser;
      if (user) {
        get(ref(db, 'users/' + user.uid))
          .then((snapshot) => {
            if (snapshot.exists()) {
              const data = snapshot.val();
              setSettingsFirstName(data.firstName || '');
              setSettingsLastName(data.lastName || '');
              if (data.avatar) {
                setAvatarData(data.avatar);
                setAvatarUri(data.avatar.link || null);
              } else {
                setAvatarData(null);
                setAvatarUri(null);
              }
            }
          })
          .catch((err) => {
            console.log('Error fetching settings data:', err);
          });
      }
    }
  }, [showSettings]);

  // ------------------------------
  // Search Users from Realtime Database (excluding self)
  // ------------------------------
  useEffect(() => {
    if (search.trim().length > 0) {
      const currentUser = auth.currentUser;
      const usersRef = ref(db, 'users');
      get(usersRef)
        .then((snapshot) => {
          if (snapshot.exists()) {
            const usersData = snapshot.val();
            const searchLower = search.toLowerCase();
            let results = [];
            for (const uid in usersData) {
              // Exclude the currently signed-in user
              if (currentUser && uid === currentUser.uid) {
                continue;
              }
              const user = usersData[uid];
              const firstName = user.firstName || '';
              const lastName = user.lastName || '';
              const email = user.email || '';
              // Combine first and last name (trim extra spaces)
              const fullName = (firstName + ' ' + lastName).trim().toLowerCase();
              // Check if the search term is part of the full name or the email
              if (
                fullName.includes(searchLower) ||
                email.toLowerCase().includes(searchLower)
              ) {
                results.push({ uid, ...user });
              }
            }
            setSearchResults(results);
          } else {
            setSearchResults([]);
          }
        })
        .catch((err) => {
          console.error('Error fetching users:', err);
          setSearchResults([]);
        });
    } else {
      setSearchResults([]);
    }
  }, [search]);

  // ------------------------------
  // Real-time Listeners for Sharing Lists
  // ------------------------------
  useEffect(() => {
    const currentUser = auth.currentUser;
    if (!currentUser) return;

    const sharingWithRef = ref(db, `users/${currentUser.uid}/sharingWith`);
    const receivingFromRef = ref(db, `users/${currentUser.uid}/receivingFrom`);

    // Listener for "Sharing With" list:
    const sharingWithListener = onValue(sharingWithRef, async (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const uids = Object.keys(data);
        const userPromises = uids.map(async (uid) => {
          const userSnap = await get(ref(db, `users/${uid}`));
          return userSnap.exists() ? { uid, ...userSnap.val() } : null;
        });
        const users = await Promise.all(userPromises);
        setSharingWithList(users.filter((u) => u !== null));
      } else {
        setSharingWithList([]);
      }
    });

    // Listener for "Receiving From" list:
    const receivingFromListener = onValue(receivingFromRef, async (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const uids = Object.keys(data);
        const userPromises = uids.map(async (uid) => {
          const userSnap = await get(ref(db, `users/${uid}`));
          return userSnap.exists() ? { uid, ...userSnap.val() } : null;
        });
        const users = await Promise.all(userPromises);
        setReceivingFromList(users.filter((u) => u !== null));
      } else {
        setReceivingFromList([]);
      }
    });

    // Cleanup the listeners when unmounting:
    return () => {
      off(sharingWithRef, 'value', sharingWithListener);
      off(receivingFromRef, 'value', receivingFromListener);
    };
  }, []);

  // ------------------------------
  // NEW: Setup realtime listeners for location updates for each user sharing with you.
  // This effect attaches a listener on each user in receivingFromList so that when their
  // "location" field changes in the DB, we update the markers state.
  // ------------------------------
  useEffect(() => {
    const listeners = {};
    if (receivingFromList.length > 0) {
      receivingFromList.forEach((user) => {
        const userRef = ref(db, `users/${user.uid}`);
        const callback = (snapshot) => {
          console.log('Location update for', user.uid);
          const userData = snapshot.val();
          if (userData && userData.location) {
            setMarkers((prev) => ({
              ...prev,
              [user.uid]: {
                ...userData,
                location: userData.location, // Expecting { latitude, longitude }
              },
            }));
          } else {
            setMarkers((prev) => {
              const newMarkers = { ...prev };
              delete newMarkers[user.uid];
              return newMarkers;
            });
          }
        };
        onValue(userRef, callback);
        listeners[user.uid] = { ref: userRef, callback };
      });
    } else {
      // No users are sharing with you—clear any markers.
      setMarkers({});
    }
    return () => {
      // Cleanup all listeners attached for each sharing user.
      Object.values(listeners).forEach(({ ref: r, callback }) => {
        off(r, 'value', callback);
      });
    };
  }, [receivingFromList]);

  // ------------------------------
  // Validation for Name Fields
  // ------------------------------
  const validateName = (name) => {
    const regex = /^[A-Za-z]+$/;
    return name.trim().length > 0 && name.length <= 20 && regex.test(name);
  };

  const handleFirstNameChange = (text) => {
    setSettingsFirstName(text);
    if (validateName(text)) {
      setFirstNameError(false);
      const user = auth.currentUser;
      if (user) {
        update(ref(db, 'users/' + user.uid), { firstName: text }).catch((err) =>
          console.log('Error updating first name:', err)
        );
      }
    } else {
      setFirstNameError(true);
    }
  };

  const handleLastNameChange = (text) => {
    setSettingsLastName(text);
    if (validateName(text)) {
      setLastNameError(false);
      const user = auth.currentUser;
      if (user) {
        update(ref(db, 'users/' + user.uid), { lastName: text }).catch((err) =>
          console.log('Error updating last name:', err)
        );
      }
    } else {
      setLastNameError(true);
    }
  };

  // ------------------------------
  // Sign Out Logic
  // ------------------------------
  const handleSignOut = async () => {
    try {
      await signOut(auth);
    } catch (error) {
      console.log('Error signing out:', error);
    }
  };

  // ------------------------------
  // New: Delete an image from Imgur using its deletehash
  // ------------------------------
  const deleteImgurImage = async (deleteHash) => {
    try {
      const authHeader = 'Client-ID ' + IMGUR_CLIENT_ID;
      const response = await fetch(`https://api.imgur.com/3/image/${deleteHash}`, {
        method: 'DELETE',
        headers: {
          Authorization: authHeader,
          Accept: 'application/json',
        },
      });
      const result = await response.json();
      if (result.success) {
        console.log('Old avatar deleted successfully from Imgur');
      } else {
        console.error('Failed to delete old avatar from Imgur:', result);
      }
    } catch (error) {
      console.error('Error deleting old avatar:', error);
    }
  };

  const resizeImageIfNeeded = async (uri, width, height) => {
    if (width <= 500 && height <= 500) {
      return uri;
    }
    const maxDimension = 1000;
    const scaleFactor = Math.min(maxDimension / width, maxDimension / height);
    const newWidth = Math.round(width * scaleFactor);
    const newHeight = Math.round(height * scaleFactor);
    const manipResult = await ImageManipulator.manipulateAsync(
      uri,
      [{ resize: { width: newWidth, height: newHeight } }],
      { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
    );
    return manipResult.uri;
  };

  // ------------------------------
  // New: Upload image to Imgur and update the DB
  // ------------------------------
  const uploadImage = async (uri) => {
    try {
      setUploading(true);
      let formData = new FormData();
      const uriParts = uri.split('.');
      const fileType = uriParts[uriParts.length - 1];
      formData.append('image', {
        uri: uri,
        name: `avatar.${fileType}`,
        type: `image/${fileType}`,
      });

      const authHeader = 'Client-ID ' + IMGUR_CLIENT_ID;
      const response = await fetch('https://api.imgur.com/3/image', {
        method: 'POST',
        headers: {
          Authorization: authHeader,
          Accept: 'application/json',
        },
        body: formData,
      });

      const result = await response.json();

      if (result.success) {
        if (avatarData && avatarData.deletehash) {
          await deleteImgurImage(avatarData.deletehash);
        }
        const currentUser = auth.currentUser;
        if (currentUser) {
          await update(ref(db, 'users/' + currentUser.uid), { avatar: result.data });
          setAvatarData(result.data);
          setAvatarUri(result.data.link);
          Alert.alert('Success', 'Avatar updated successfully.');
        } else {
          Alert.alert('Error', 'User not logged in.');
        }
      } else {
        console.error('Imgur upload failed:', result);
        Alert.alert('Upload failed', 'Failed to upload image to Imgur.');
      }
    } catch (error) {
      console.error('Error uploading image:', error);
      Alert.alert('Error', 'An error occurred while uploading the image.');
    } finally {
      setUploading(false);
    }
  };

  // ------------------------------
  // New: Handle image selection using expo-image-picker
  // ------------------------------
  const handleSelectImage = async () => {
    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (!permissionResult.granted) {
      Alert.alert('Permission required', 'Permission to access the media library is required!');
      return;
    }

    let pickerResult = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });

    if (!pickerResult.canceled) {
      const asset = pickerResult.assets[0];
      const resizedUri = await resizeImageIfNeeded(asset.uri, asset.width, asset.height);
      await uploadImage(resizedUri);
    }
  };

  // ------------------------------
  // New: Handle removing the current profile picture
  // ------------------------------
  const handleRemovePicture = async () => {
    if (!avatarData || !avatarData.deletehash) {
      Alert.alert('No avatar', 'No avatar to remove.');
      return;
    }
    try {
      setUploading(true);
      await deleteImgurImage(avatarData.deletehash);
      const currentUser = auth.currentUser;
      if (currentUser) {
        await update(ref(db, 'users/' + currentUser.uid), { avatar: null });
        setAvatarData(null);
        setAvatarUri(null);
        Alert.alert('Success', 'Avatar removed successfully.');
      } else {
        Alert.alert('Error', 'User not logged in.');
      }
    } catch (error) {
      console.error('Error removing avatar:', error);
      Alert.alert('Error', 'An error occurred while removing the avatar.');
    } finally {
      setUploading(false);
    }
  };

  // ------------------------------
  // New: Reusable Component for Displaying a User with Sharing Status
  // ------------------------------
  const UserListItem = ({ user, onPress }) => {
    const [statusText, setStatusText] = useState('');

    useEffect(() => {
      const fetchStatus = async () => {
        const currentUser = auth.currentUser;
        if (!currentUser) return;
        try {
          const status = await getSharingStatus(currentUser.uid, user.uid);
          let text = '';
          if (status.amSharing && status.amReceiving) {
            text = 'Both of you are sharing';
          } else if (status.amSharing && !status.amReceiving) {
            text = 'Receiving your location';
          } else if (!status.amSharing && status.amReceiving) {
            text = 'Is sharing with you';
          } else {
            text = 'Neither of you are sharing';
          }
          setStatusText(text);
        } catch (err) {
          console.error(err);
        }
      };
      fetchStatus();
    }, [user]);

    return (
      <ListItem bottomDivider onPress={() => onPress(user)}>
        <Avatar
          rounded
          source={
            user.avatar && user.avatar.link
              ? { uri: user.avatar.link }
              : undefined
          }
          icon={
            !user.avatar || !user.avatar.link
              ? { name: 'person-outline', type: 'material', size: 26 }
              : undefined
          }
          containerStyle={
            !user.avatar || !user.avatar.link
              ? { backgroundColor: '#c2c2c2' }
              : {}
          }
        />
        <ListItem.Content>
          <ListItem.Title>
            {(`${user.firstName || ''} ${user.lastName || ''}`).trim()}
          </ListItem.Title>
          <ListItem.Subtitle>{statusText}</ListItem.Subtitle>
        </ListItem.Content>
      </ListItem>
    );
  };

  // ------------------------------
  // Sharing Dialog (same as before)
  // ------------------------------
  function SharingDialog({
    targetUser,
    sharingStatus,
    onShare,
    onStopSharing,
    onStopReceiving,
    onClose,
  }) {
    let message = '';
    let actions = [];

    if (sharingStatus.amSharing && !sharingStatus.amReceiving) {
      // Case 1: You are sharing, they are not.
      message = `You are sharing your location with ${targetUser.firstName}`;
      actions.push({ title: 'Stop Sharing My Location', onPress: onStopSharing });
    } else if (!sharingStatus.amSharing && sharingStatus.amReceiving) {
      // Case 2: They are sharing with you, but you’re not.
      message = `${targetUser.firstName} is sharing their location`;
      actions.push({ title: 'Share My Location', onPress: onShare });
      actions.push({ title: `Remove ${targetUser.firstName}`, onPress: onStopReceiving });
    } else if (sharingStatus.amSharing && sharingStatus.amReceiving) {
      // Case 3: Both are sharing.
      message = 'You are both sharing';
      actions.push({ title: 'Stop Sharing My Location', onPress: onStopSharing });
      actions.push({ title: `Remove ${targetUser.firstName}`, onPress: onStopReceiving });
    } else {
      // Case 4: Neither are sharing.
      message = 'Neither of you are sharing';
      actions.push({ title: 'Share My Location', onPress: onShare });
    }

    return (
      <View style={SharingStyles.dialogContainer}>
        <Text style={SharingStyles.dialogMessage}>{message}</Text>
        {actions.map((action, index) => (
          <View key={index} style={SharingStyles.buttonContainer}>
            <Button
              title={action.title}
              onPress={() => {
                action.onPress();
                onClose();
              }}
            />
          </View>
        ))}
        <View style={SharingStyles.buttonContainer}>
          <Button title="Cancel" onPress={onClose} />
        </View>
      </View>
    );
  }

  // Called when a search result or list item is tapped.
  const handleUserPress = async (user) => {
    const currentUser = auth.currentUser;
    if (!currentUser) return;

    // Check sharing status between the current user and the tapped user.
    const status = await getSharingStatus(currentUser.uid, user.uid);
    setSharingStatus(status);
    setSelectedUser(user);
    setShowSharingDialog(true);
  };

  // ------------------------------
  // Render
  // ------------------------------
  return (
    <View style={styles.container}>
      {/* Full-screen Map */}
      <MapView
        style={StyleSheet.absoluteFillObject}
        attributionEnabled={false}
        logoEnabled={false}
        scaleBarEnabled={false}
        compassEnabled={true}
        compassViewPosition={1}
        compassViewMargins={{ x: 15, y: 64 }}
        compassFadeWhenNorth={false}
      >
        {/* Shows a blue dot for user location */}
        <LocationPuck
          topImage="topImage"
          visible={true}
          scale={['interpolate', ['linear'], ['zoom'], 10, 1.0, 20, 4.0]}
          pulsing={{
            isEnabled: true,
            color: 'teal',
            radius: 50.0,
          }}
        />

        {/* NEW: Render markers for each user sharing their location with you */}
        {Object.keys(markers).map((uid) => {
          const markerData = markers[uid];
          if (!markerData.location) return null;
          return (
            <MarkerView
              key={uid}
              id={uid}
              coordinate={[
                markerData.location.longitude,
                markerData.location.latitude,
              ]}
              allowOverlapWithPuck={true}
            >
              <UserMarker user={markerData} />
            </MarkerView>
          );
        })}
      </MapView>

      {/* Top row with Settings (left) and Friends (right) buttons */}
      <View style={styles.topRow}>
        <TouchableOpacity style={styles.iconButton} onPress={() => setShowSettings(true)}>
          <MaterialIcons name="settings" size={24} color="black" />
        </TouchableOpacity>
        <TouchableOpacity style={styles.iconButton} onPress={() => setShowSocial(true)}>
          <FontAwesome5 name="user-friends" size={20} color="black" />
        </TouchableOpacity>
      </View>

      {/* Current location text overlaid at bottom-right */}
      <View style={styles.locationInfo}>
        {currentLocation ? (
          <Text style={styles.locationText}>
            Lat: {currentLocation.latitude.toFixed(6)}
            {'\n'}Lng: {currentLocation.longitude.toFixed(6)}
          </Text>
        ) : (
          <Text style={styles.locationText}>No location yet...</Text>
        )}
      </View>

      {/* Sign out button overlaid at bottom-left */}
      <TouchableOpacity style={styles.signOutButton} onPress={handleSignOut}>
        <Text style={styles.signOutText}>Log Out</Text>
      </TouchableOpacity>

      {/* ------------- Settings Modal ------------- */}
      <Modal
        animationType="slide"
        transparent={false}
        visible={showSettings}
        onRequestClose={() => setShowSettings(false)}
      >
        <SafeAreaView style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>Settings</Text>
            <TouchableOpacity onPress={() => setShowSettings(false)}>
              <MaterialIcons name="close" size={28} color="#000" />
            </TouchableOpacity>
          </View>
          <ScrollView style={styles.modalContent} contentContainerStyle={styles.modalScroll}>
            <View style={styles.avatarContainer}>
              <Avatar
                size={100}
                rounded
                source={avatarUri ? { uri: avatarUri } : null}
                icon={!avatarUri ? { name: 'person', type: 'material' } : undefined}
                containerStyle={styles.avatar}
              />
              {uploading && (
                <ActivityIndicator
                  style={{ marginVertical: 10 }}
                  size="small"
                  color="#00ADB5"
                />
              )}
              <View style={styles.avatarButtonsContainer}>
                <TouchableOpacity
                  style={styles.avatarButton}
                  onPress={handleSelectImage}
                  disabled={uploading}
                >
                  <Text style={styles.avatarButtonText}>Select Image</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={styles.avatarButton}
                  onPress={handleRemovePicture}
                  disabled={uploading}
                >
                  <Text style={styles.avatarButtonText}>Remove Picture</Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* First Name Field */}
            <Text style={styles.label}>First Name</Text>
            <TextInput
              style={[styles.input, firstNameError && styles.errorInput]}
              placeholder="First Name"
              value={settingsFirstName}
              onChangeText={handleFirstNameChange}
            />

            {/* Last Name Field */}
            <Text style={styles.label}>Last Name</Text>
            <TextInput
              style={[styles.input, lastNameError && styles.errorInput]}
              placeholder="Last Name"
              value={settingsLastName}
              onChangeText={handleLastNameChange}
            />
          </ScrollView>
        </SafeAreaView>
      </Modal>

      {/* ------------- People (Social) Modal ------------- */}
      <Modal
        animationType="slide"
        transparent={false}
        visible={showSocial}
        onRequestClose={() => setShowSocial(false)}
      >
        <SafeAreaView style={styles.modalContainer}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>People</Text>
            <TouchableOpacity onPress={() => setShowSocial(false)}>
              <MaterialIcons name="close" size={28} color="#000" />
            </TouchableOpacity>
          </View>
          <ScrollView style={styles.modalContent} contentContainerStyle={styles.modalScroll}>
            <SearchBar
              placeholder="Search..."
              onChangeText={setSearch}
              value={search}
              platform="default"
              containerStyle={styles.searchContainer}
              inputContainerStyle={styles.searchInputContainer}
              inputStyle={styles.searchInput}
            />

            {/* If there is at least one character in the search field, show search results */}
            {search.trim().length > 0 ? (
              <>
                {searchResults.length > 0 ? (
                  searchResults.map((user) => (
                    <UserListItem key={user.uid} user={user} onPress={handleUserPress} />
                  ))
                ) : (
                  <Text style={{ textAlign: 'center', marginTop: 20 }}>
                    No users found.
                  </Text>
                )}
              </>
            ) : (
              <>
                <ListItem.Accordion
                  content={
                    <ListItem.Content>
                      <ListItem.Title>Sharing With</ListItem.Title>
                    </ListItem.Content>
                  }
                  isExpanded={expanded1}
                  onPress={() => setExpanded1(!expanded1)}
                >
                  {sharingWithList.length > 0 ? (
                    sharingWithList.map((user) => (
                      <UserListItem key={user.uid} user={user} onPress={handleUserPress} />
                    ))
                  ) : (
                    <Text style={{ margin: 10, textAlign: 'center' }}>
                      You are not sharing your location yet.
                    </Text>
                  )}
                </ListItem.Accordion>

                <Divider
                  style={{ width: '100%' }}
                  insetType="middle"
                  width={1}
                  orientation="horizontal"
                />

                <ListItem.Accordion
                  content={
                    <ListItem.Content>
                      <ListItem.Title>Receiving Locations</ListItem.Title>
                    </ListItem.Content>
                  }
                  isExpanded={expanded2}
                  onPress={() => setExpanded2(!expanded2)}
                >
                  {receivingFromList.length > 0 ? (
                    receivingFromList.map((user) => (
                      <UserListItem key={user.uid} user={user} onPress={handleUserPress} />
                    ))
                  ) : (
                    <Text style={{ margin: 10, textAlign: 'center' }}>
                      Nobody has shared with you yet.
                    </Text>
                  )}
                </ListItem.Accordion>
              </>
            )}
          </ScrollView>
        </SafeAreaView>
      </Modal>

      {showSharingDialog && selectedUser && (
        <Modal
          animationType="fade"
          transparent={true}
          visible={showSharingDialog}
          onBackdropPress={() => setShowSharingDialog(false)}
          onRequestClose={() => setShowSharingDialog(false)}
        >
          <View style={dialogStyles.overlay}>
            <View style={dialogStyles.dialogBox}>
              <SharingDialog
                targetUser={selectedUser}
                sharingStatus={sharingStatus}
                onShare={async () => {
                  await shareLocation(auth.currentUser.uid, selectedUser.uid);
                  // Optionally, update sharingStatus if needed.
                }}
                onStopSharing={async () => {
                  await stopSharingLocation(auth.currentUser.uid, selectedUser.uid);
                }}
                onStopReceiving={async () => {
                  await stopReceivingLocation(auth.currentUser.uid, selectedUser.uid);
                }}
                onClose={() => setShowSharingDialog(false)}
              />
            </View>
          </View>
        </Modal>
      )}
    </View>
  );
}

// ------------------------------
// Styles
// ------------------------------
const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  topRow: {
    position: 'absolute',
    top: 10,
    left: 0,
    right: 0,
    flexDirection: 'row',
    justifyContent: 'space-between',
    paddingHorizontal: 15,
    zIndex: 999,
  },
  iconButton: {
    width: 47,
    height: 47,
    borderRadius: 25,
    backgroundColor: '#fff',
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 3,
  },
  locationInfo: {
    position: 'absolute',
    bottom: 40,
    right: 15,
    backgroundColor: 'rgba(0,0,0,0.3)',
    padding: 8,
    borderRadius: 5,
  },
  locationText: {
    color: '#fff',
    textAlign: 'left',
  },
  signOutButton: {
    position: 'absolute',
    bottom: 40,
    left: 15,
    backgroundColor: '#f54242',
    borderRadius: 5,
    paddingHorizontal: 15,
    paddingVertical: 10,
  },
  signOutText: {
    color: '#fff',
    fontSize: 16,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: '#fff',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  modalTitle: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#000',
  },
  modalContent: {
    flex: 1,
    paddingHorizontal: 20,
    paddingVertical: 10,
  },
  modalScroll: {
    flexGrow: 1,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
    padding: 10,
    marginBottom: 15,
  },
  errorInput: {
    borderColor: 'red',
  },
  label: {
    fontSize: 16,
    color: '#000',
    marginBottom: 5,
    marginTop: 15,
  },
  searchContainer: {
    backgroundColor: 'transparent',
    borderTopWidth: 0,
    borderBottomWidth: 0,
    paddingHorizontal: 0,
    marginBottom: 20,
  },
  searchInputContainer: {
    backgroundColor: '#eee',
    borderRadius: 5,
  },
  searchInput: {
    color: '#000',
  },
  avatarContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  avatar: {
    backgroundColor: '#ccc',
  },
  avatarButtonsContainer: {
    flexDirection: 'row',
    marginTop: 10,
  },
  avatarButton: {
    backgroundColor: '#00ADB5',
    paddingHorizontal: 15,
    paddingVertical: 8,
    borderRadius: 5,
    marginHorizontal: 5,
  },
  avatarButtonText: {
    color: '#fff',
  },
});

const dialogStyles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  dialogBox: {
    backgroundColor: '#fff',
    borderRadius: 8,
    padding: 20,
    marginHorizontal: 20,
    width: '80%',
  },
});

const SharingStyles = StyleSheet.create({
  dialogContainer: {
    backgroundColor: '#fff',
    padding: 20,
    marginHorizontal: 20,
    borderRadius: 8,
    alignItems: 'center',
  },
  dialogMessage: {
    fontSize: 16,
    marginBottom: 15,
    textAlign: 'center',
  },
  buttonContainer: {
    marginVertical: 5,
    width: '100%',
  },
});
```

sharingUtils.js
```javascript
// sharingUtils.js
import { ref, update, get } from 'firebase/database';
import { db } from './firebaseConfig';

/**
 * Returns the sharing status between the current user and a target user.
 * @param {string} currentUid – Your UID.
 * @param {string} targetUid – The target user's UID.
 * @returns {Promise<{amSharing: boolean, amReceiving: boolean}>}
 */
export const getSharingStatus = async (currentUid, targetUid) => {
  try {
    // Check whether targetUid is in your sharingWith and receivingFrom lists.
    const sharingWithSnap = await get(ref(db, `users/${currentUid}/sharingWith/${targetUid}`));
    const receivingFromSnap = await get(ref(db, `users/${currentUid}/receivingFrom/${targetUid}`));
    return {
      amSharing: sharingWithSnap.exists(),
      amReceiving: receivingFromSnap.exists(),
    };
  } catch (error) {
    console.error('Error fetching sharing status:', error);
    return { amSharing: false, amReceiving: false };
  }
};

/**
 * Begins sharing your location with the target user.
 */
export const shareLocation = async (currentUid, targetUid) => {
  try {
    const updates = {};
    // Add targetUid to your sharingWith list…
    updates[`users/${currentUid}/sharingWith/${targetUid}`] = true;
    // …and add your uid to the target's receivingFrom list.
    updates[`users/${targetUid}/receivingFrom/${currentUid}`] = true;
    await update(ref(db), updates);
  } catch (error) {
    console.error('Error sharing location:', error);
  }
};

/**
 * Stops sharing your location with the target user.
 */
export const stopSharingLocation = async (currentUid, targetUid) => {
  try {
    const updates = {};
    // Remove targetUid from your sharingWith list…
    updates[`users/${currentUid}/sharingWith/${targetUid}`] = null;
    // …and remove your uid from the target's receivingFrom list.
    updates[`users/${targetUid}/receivingFrom/${currentUid}`] = null;
    await update(ref(db), updates);
  } catch (error) {
    console.error('Error stopping sharing location:', error);
  }
};

/**
 * Stops receiving the target user's location.
 */
export const stopReceivingLocation = async (currentUid, targetUid) => {
  try {
    const updates = {};
    // Remove targetUid from your receivingFrom list…
    updates[`users/${currentUid}/receivingFrom/${targetUid}`] = null;
    // …and remove your uid from the target's sharingWith list.
    updates[`users/${targetUid}/sharingWith/${currentUid}`] = null;
    await update(ref(db), updates);
  } catch (error) {
    console.error('Error stopping receiving location:', error);
  }
};
```

firebaseConfig.js
```javascript
// firebaseConfig.js
import { initializeApp } from 'firebase/app';
import { getDatabase } from 'firebase/database';
import { initializeAuth, getReactNativePersistence } from 'firebase/auth';
import AsyncStorage from '@react-native-async-storage/async-storage';

// Replace with your own Firebase config!
const firebaseConfig = {
    apiKey: "AIzaSyAR24CQPymO-X5-6L-JeKRGfyqXm3n8MOs",
    authDomain: "totob12-loco.firebaseapp.com",
    projectId: "totob12-loco",
    storageBucket: "totob12-loco.firebasestorage.app",
    messagingSenderId: "1079141322842",
    appId: "1:1079141322842:web:ea9606c2ad097ea3f30863"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);

// Set up Auth with persistence:
export const auth = initializeAuth(app, {
    persistence: getReactNativePersistence(AsyncStorage),
});

// Initialize and export the Realtime Database instead of Firestore:
export const db = getDatabase(app);
```

package.json
```json
{
  "name": "loco",
  "license": "0BSD",
  "version": "0.1.4",
  "main": "index.js",
  "scripts": {
    "start": "expo start --dev-client",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-navigation/native": "^7.0.14",
    "@react-navigation/stack": "^7.1.1",
    "@rneui/base": "^4.0.0-rc.7",
    "@rneui/themed": "^4.0.0-rc.8",
    "@rnmapbox/maps": "^10.1.33",
    "dotenv": "^16.4.7",
    "expo": "~52.0.24",
    "expo-background-fetch": "~13.0.4",
    "expo-dev-client": "~5.0.9",
    "expo-image-manipulator": "~13.0.6",
    "expo-image-picker": "~16.0.5",
    "expo-intent-launcher": "~12.0.2",
    "expo-location": "~18.0.5",
    "expo-status-bar": "~2.0.0",
    "expo-task-manager": "~12.0.4",
    "firebase": "^11.1.0",
    "react": "18.3.1",
    "react-native": "0.76.5",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-keyboard-aware-scroll-view": "^0.9.5",
    "react-native-maps": "1.18.0",
    "react-native-radar": "^3.19.1",
    "react-native-reanimated": "~3.16.1",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0"
  },
  "private": true
}
```

app.json
```json
import 'dotenv/config';

export default ({ config }) => {
  return {
    ...config,
    "name": "loco",
    "slug": "loco",
    "version": "0.1.4",
    "orientation": "portrait",
    "icon": "./assets/icon.jpg",
    "userInterfaceStyle": "dark",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#212832"
    },
    "newArchEnabled": false,
    "experiments": {
      "turboModules": false,
      "coreModules": false,
      "unoptimizedReports": false,
      "enableAsyncDefaults": false,
      "concurrentRoot": false,
      "fabric": false
    },
    "plugins": [
      [
        "react-native-radar",
        {
          "iosFraud": false,
          "iosNSLocationWhenInUseUsageDescription": "We use your location to help share your position in real-time.",
          "iosNSLocationAlwaysAndWhenInUseUsageDescription": "Background location is used so your friends can see your location even if the app is closed.",
          "iosBackgroundMode": true,
          "androidFraud": true,
          "androidBackgroundPermission": true,
          "androidFineLocationPermission": true,
          "addRadarSDKMotion": false
        }
      ],
      [
        "@rnmapbox/maps",
        {
          "RNMapboxMapsDownloadToken": process.env.MAPBOX_DOWNLOADS_TOKEN,
          "RNMapboxMapsVersion": "11.0.0"
        }
      ],
      [
        "expo-location",
        {
          "locationWhenInUsePermission": "Show current location on map."
        }
      ],
      ["expo-image-picker"]
    ],
    "ios": {
      "supportsTablet": true,
      "infoPlist": {
        "UIBackgroundModes": [
          "location",
          "fetch"
        ],
        "NSLocationWhenInUseUsageDescription": "Show current location on map",
        "NSLocationAlwaysAndWhenInUseUsageDescription": "Background location usage..."
      },
      "config": {
        "googleMapsApiKey": "AIzaSyCCkJk7m5UqYt9_dHHxjA0zzvWKadSn41U"
      },
    },
    "android": {
      "package": "com.antoninbeliard.loco",
      "icon": "./assets/icon.png",
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#212832"
      },
      "permissions": [
        "ACCESS_FINE_LOCATION",
        "ACCESS_COARSE_LOCATION",
        "ACCESS_BACKGROUND_LOCATION",
        "android.permission.ACCESS_COARSE_LOCATION",
        "android.permission.ACCESS_FINE_LOCATION",
        "android.permission.ACCESS_BACKGROUND_LOCATION",
        "android.permission.FOREGROUND_SERVICE"
      ],
      "config": {
        "googleMaps": {
          "apiKey": "AIzaSyAgtPIWpSfr1a2dxUdBxXVw7Xah1yqL9YQ"
        }
      }
    },
    "extra": {
      "eas": {
        "projectId": "eacea42d-f4e8-4a94-b43a-f19dc934865e"
      }
    }
  };
};
```

This all works well, but I want to now add a new feature to the home screen. I want to have a Bottom Sheet that will show a list of all the user that have shared their location with me. Each user item in that list should look like the ones from the People modal, except have a placeholder text instead of any status text (and don't have them do anything on click for now). I want it to look and feel like iOS's FindMy app: the bottom sheet should take up a bit less than half the screen by default, can be fully minimised, but can also be swipped to take up the entire screen height. I want you to fully develop and implement this. Here is some documentation to help:

```
React Native Bottom Sheet
Reanimated v3 version Reanimated v2 version Reanimated v1 version
license npm runs with expo
NPM Downloads

A performant interactive bottom sheet with fully configurable options 🚀

Features
⭐️ Support React Native Web, read more.
⭐️ Dynamic Sizing, read more.
⭐️ Support FlashList, read more.
Modal presentation view, Bottom Sheet Modal.
Smooth gesture interactions & snapping animations.
Seamless keyboard handling for iOS & Android.
Support pull to refresh for scrollables.
Support FlatList, SectionList, ScrollView & View scrolling interactions, read more.
Support React Navigation Integration, read more.
Compatible with Reanimated v1-3.
Accessibility support.
Written in TypeScript.
Installation
yarn add @gorhom/bottom-sheet@^5

Dependencies
This library needs these dependencies to be installed in your project before you can use it:

yarn add react-native-reanimated react-native-gesture-handler

Using Expo?

npx expo install react-native-reanimated react-native-gesture-handler

info
React Native Gesture Handler v3 needs extra steps to finalize its installation, please follow their installation instructions. Please make sure to wrap your App with GestureHandlerRootView when you've upgraded to React Native Gesture Handler ^3.

React Native Reanimated v3 needs extra steps to finalize its installation, please follow their installation instructions.
```

```
Usage
Here is a simple usage of the Bottom Sheet, with non-scrollable content. For more scrollable usage please read Scrollables.

import React, { useCallback, useMemo, useRef } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import BottomSheet, { BottomSheetView } from '@gorhom/bottom-sheet';

const App = () => {
  // ref
  const bottomSheetRef = useRef<BottomSheet>(null);

  // callbacks
  const handleSheetChanges = useCallback((index: number) => {
    console.log('handleSheetChanges', index);
  }, []);

  // renders
  return (
    <GestureHandlerRootView style={styles.container}>
      <BottomSheet
        ref={bottomSheetRef}
        onChange={handleSheetChanges}
      >
        <BottomSheetView style={styles.contentContainer}>
          <Text>Awesome 🎉</Text>
        </BottomSheetView>
      </BottomSheet>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'grey',
  },
  contentContainer: {
    flex: 1,
    padding: 36,
    alignItems: 'center',
  },
});

export default App;
```

```
BottomSheetScrollView
A pre-integrated React Native ScrollView with BottomSheet gestures.

Props
Inherits ScrollViewProps from react-native.

focusHook
This needed when bottom sheet used with multiple scrollables to allow bottom sheet detect the current scrollable ref, especially when used with React Navigation. You will need to provide useFocusEffect from @react-navigation/native.

type	default	required
function	React.useEffect	NO
Ignored Props
These props will be ignored if they were passed, because of the internal integration that uses them.

scrollEventThrottle
decelerationRate
onScrollBeginDrag
Example
import React, { useCallback, useRef, useMemo } from "react";
import { StyleSheet, View, Text, Button } from "react-native";
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import BottomSheet, { BottomSheetScrollView } from "@gorhom/bottom-sheet";

const App = () => {
  // hooks
  const sheetRef = useRef<BottomSheet>(null);

  // variables
  const data = useMemo(
    () =>
      Array(50)
        .fill(0)
        .map((_, index) => `index-${index}`),
    []
  );
  const snapPoints = useMemo(() => ["25%", "50%", "90%"], []);

  // callbacks
  const handleSheetChange = useCallback((index) => {
    console.log("handleSheetChange", index);
  }, []);
  const handleSnapPress = useCallback((index) => {
    sheetRef.current?.snapToIndex(index);
  }, []);
  const handleClosePress = useCallback(() => {
    sheetRef.current?.close();
  }, []);

  // render
  const renderItem = useCallback(
    (item) => (
      <View key={item} style={styles.itemContainer}>
        <Text>{item}</Text>
      </View>
    ),
    []
  );
  return (
    <GestureHandlerRootView style={styles.container}>
      <Button title="Snap To 90%" onPress={() => handleSnapPress(2)} />
      <Button title="Snap To 50%" onPress={() => handleSnapPress(1)} />
      <Button title="Snap To 25%" onPress={() => handleSnapPress(0)} />
      <Button title="Close" onPress={() => handleClosePress()} />
      <BottomSheet
        ref={sheetRef}
        index={1}
        snapPoints={snapPoints}
        enableDynamicSizing={false}
        onChange={handleSheetChange}
      >
        <BottomSheetScrollView contentContainerStyle={styles.contentContainer}>
          {data.map(renderItem)}
        </BottomSheetScrollView>
      </BottomSheet>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    paddingTop: 200,
  },
  contentContainer: {
    backgroundColor: "white",
  },
  itemContainer: {
    padding: 6,
    margin: 6,
    backgroundColor: "#eee",
  },
});

export default App;
```